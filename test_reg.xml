<?xml version="1.0" encoding="utf-8"?><testsuites><testsuite name="pytest" errors="0" failures="15" skipped="0" tests="24" time="643.931" timestamp="2025-04-24T14:29:32.892680-04:00" hostname="DESKTOP-7DRO9R6"><testcase classname="tests.test_registration" name="test_registration_cases[test_data0]" time="18.140" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data1]" time="6.871" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data2]" time="7.091" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data3]" time="7.102" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data4]" time="15.458"><failure message="Failed: Test case 'Invalid email format' failed: Unexpected successful login for failure - invalid email.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005CB7820&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005CB75C0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005CB7950&gt;, ...}
test_data = ('Invalid email format', 'FirstName', 'LastName', 'a@a', '12345', 'failure - invalid email')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005CB7820&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005CB75C0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005CB7950&gt;, ...}
test_name = 'Invalid email format', first_name = 'FirstName', last_name = 'LastName', email = 'a@a', password = '12345', expected_outcome = 'failure - invalid email'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
&gt;                   pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
E                   Failed: Test case 'Invalid email format' failed: Unexpected successful login for failure - invalid email.

tests\test_registration.py:83: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data5]" time="7.022" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data6]" time="6.969" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data7]" time="7.216" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data8]" time="15.835"><failure message="Failed: Test case 'Short password' failed: Unexpected successful login for failure - password too short.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005CCB350&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005CCB150&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005CCB450&gt;, ...}
test_data = ('Short password', 'FirstName', 'LastName', 'test9999@example.com', '123', 'failure - password too short')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005CCB350&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005CCB150&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005CCB450&gt;, ...}
test_name = 'Short password', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '123'
expected_outcome = 'failure - password too short'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
&gt;                   pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
E                   Failed: Test case 'Short password' failed: Unexpected successful login for failure - password too short.

tests\test_registration.py:83: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data9]" time="41.079"><failure message="Failed: Test case 'Long password' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005E21B50&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005E21950&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005E21C50&gt;, ...}
test_name = 'Long password', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '123456789012345678901234567890'
expected_outcome = 'failure - password too long'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000004DF3150&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x000000000097AD40&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005E21B50&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005E21950&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005E21C50&gt;, ...}
test_data = ('Long password', 'FirstName', 'LastName', 'test9999@example.com', '123456789012345678901234567890', 'failure - password too long')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005E21B50&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005E21950&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005E21C50&gt;, ...}
test_name = 'Long password', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '123456789012345678901234567890'
expected_outcome = 'failure - password too long'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Long password' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data10]" time="41.232"><failure message="Failed: Test case 'Special characters in name' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009497C0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009495E0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009498B0&gt;, ...}
test_name = 'Special characters in name', first_name = 'First@Name', last_name = 'Last#Name', email = 'test9999@example.com', password = '12345'
expected_outcome = 'failure - invalid name'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005E23A50&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x000000000097B920&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009497C0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009495E0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009498B0&gt;, ...}
test_data = ('Special characters in name', 'First@Name', 'Last#Name', 'test9999@example.com', '12345', 'failure - invalid name')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009497C0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009495E0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009498B0&gt;, ...}
test_name = 'Special characters in name', first_name = 'First@Name', last_name = 'Last#Name', email = 'test9999@example.com', password = '12345'
expected_outcome = 'failure - invalid name'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Special characters in name' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data11]" time="41.197"><failure message="Failed: Test case 'Whitespace-only first name' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009B47D0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009B45F0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009B48C0&gt;, ...}
test_name = 'Whitespace-only first name', first_name = '   ', last_name = 'LastName', email = 'test9999@example.com', password = '12345'
expected_outcome = 'failure - first name required'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005E22D50&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x000000000093A660&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009B47D0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009B45F0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009B48C0&gt;, ...}
test_data = ('Whitespace-only first name', '   ', 'LastName', 'test9999@example.com', '12345', 'failure - first name required')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009B47D0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009B45F0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009B48C0&gt;, ...}
test_name = 'Whitespace-only first name', first_name = '   ', last_name = 'LastName', email = 'test9999@example.com', password = '12345'
expected_outcome = 'failure - first name required'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Whitespace-only first name' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data12]" time="41.266"><failure message="Failed: Test case 'Whitespace-only last name' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000000941550&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000000940C90&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000000940D70&gt;, ...}
test_name = 'Whitespace-only last name', first_name = 'FirstName', last_name = '   ', email = 'test9999@example.com', password = '12345'
expected_outcome = 'failure - last name required'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005E21750&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x00000000009B8720&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000000941550&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000000940C90&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000000940D70&gt;, ...}
test_data = ('Whitespace-only last name', 'FirstName', '   ', 'test9999@example.com', '12345', 'failure - last name required')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000000941550&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000000940C90&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000000940D70&gt;, ...}
test_name = 'Whitespace-only last name', first_name = 'FirstName', last_name = '   ', email = 'test9999@example.com', password = '12345'
expected_outcome = 'failure - last name required'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Whitespace-only last name' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data13]" time="41.150"><failure message="Failed: Test case 'Whitespace-only password' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005D86CF0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005D87AF0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005D86890&gt;, ...}
test_name = 'Whitespace-only password', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '   '
expected_outcome = 'failure - password required'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005CCAB50&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x00000000009B2E80&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005D86CF0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005D87AF0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005D86890&gt;, ...}
test_data = ('Whitespace-only password', 'FirstName', 'LastName', 'test9999@example.com', '   ', 'failure - password required')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005D86CF0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005D87AF0&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005D86890&gt;, ...}
test_name = 'Whitespace-only password', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '   '
expected_outcome = 'failure - password required'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Whitespace-only password' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data14]" time="41.091"><failure message="Failed: Test case 'Duplicate email registration' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005C8B2B0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005C8A410&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005C8B380&gt;, ...}
test_name = 'Duplicate email registration', first_name = 'FirstName', last_name = 'LastName', email = 'team2@taqc.com', password = '12345'
expected_outcome = 'failure - email already in use'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005CC8250&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000005D689A0&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005C8B2B0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005C8A410&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005C8B380&gt;, ...}
test_data = ('Duplicate email registration', 'FirstName', 'LastName', 'team2@taqc.com', '12345', 'failure - email already in use')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005C8B2B0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005C8A410&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005C8B380&gt;, ...}
test_name = 'Duplicate email registration', first_name = 'FirstName', last_name = 'LastName', email = 'team2@taqc.com', password = '12345'
expected_outcome = 'failure - email already in use'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Duplicate email registration' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data15]" time="6.860" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data16]" time="41.052"><failure message="Failed: Test case 'Email with special characters' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005D4DFD0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005D4DE50&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005D4E090&gt;, ...}
test_name = 'Email with special characters', first_name = 'FirstName', last_name = 'LastName', email = 'test!@domain.com', password = '12345'
expected_outcome = 'failure - invalid email'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005CC8550&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000005CF5760&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005D4DFD0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005D4DE50&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005D4E090&gt;, ...}
test_data = ('Email with special characters', 'FirstName', 'LastName', 'test!@domain.com', '12345', 'failure - invalid email')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005D4DFD0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005D4DE50&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005D4E090&gt;, ...}
test_name = 'Email with special characters', first_name = 'FirstName', last_name = 'LastName', email = 'test!@domain.com', password = '12345'
expected_outcome = 'failure - invalid email'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Email with special characters' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data17]" time="7.093" /><testcase classname="tests.test_registration" name="test_registration_cases[test_data18]" time="42.178"><failure message="Failed: Test case 'Password with only numbers' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009CB6A0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009CB540&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009CB750&gt;, ...}
test_name = 'Password with only numbers', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '12345678'
expected_outcome = 'failure - weak password'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005CC8050&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000005CA6480&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009CB6A0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009CB540&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009CB750&gt;, ...}
test_data = ('Password with only numbers', 'FirstName', 'LastName', 'test9999@example.com', '12345678', 'failure - weak password')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x00000000009CB6A0&gt;, 'home': &lt;pages.automation_p...ect at 0x00000000009CB540&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x00000000009CB750&gt;, ...}
test_name = 'Password with only numbers', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '12345678'
expected_outcome = 'failure - weak password'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Password with only numbers' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data19]" time="41.226"><failure message="Failed: Test case 'Password with only letters' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005DC0C30&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005DC0410&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005DC3BB0&gt;, ...}
test_name = 'Password with only letters', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = 'abcdefgh'
expected_outcome = 'failure - weak password'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000004DF3450&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000000A02F20&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005DC0C30&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005DC0410&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005DC3BB0&gt;, ...}
test_data = ('Password with only letters', 'FirstName', 'LastName', 'test9999@example.com', 'abcdefgh', 'failure - weak password')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005DC0C30&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005DC0410&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005DC3BB0&gt;, ...}
test_name = 'Password with only letters', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = 'abcdefgh'
expected_outcome = 'failure - weak password'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Password with only letters' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data20]" time="41.118"><failure message="Failed: Test case 'Password with special characters only' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005DC3250&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005DC1C70&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005DC1950&gt;, ...}
test_name = 'Password with special characters only', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '@#$%^&amp;*'
expected_outcome = 'failure - weak password'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000004DF3A50&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000005CA58A0&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005DC3250&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005DC1C70&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005DC1950&gt;, ...}
test_data = ('Password with special characters only', 'FirstName', 'LastName', 'test9999@example.com', '@#$%^&amp;*', 'failure - weak password')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005DC3250&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005DC1C70&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005DC1950&gt;, ...}
test_name = 'Password with special characters only', first_name = 'FirstName', last_name = 'LastName', email = 'test9999@example.com', password = '@#$%^&amp;*'
expected_outcome = 'failure - weak password'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Password with special characters only' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data21]" time="41.032"><failure message="Failed: Test case 'Very long email' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005E92570&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005E92060&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005E92600&gt;, ...}
test_name = 'Very long email', first_name = 'FirstName', last_name = 'LastName'
email = 'testaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@example.com'
password = '12345', expected_outcome = 'failure - email too long'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005CC8C50&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000005CA6980&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005E92570&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005E92060&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005E92600&gt;, ...}
test_data = ('Very long email', 'FirstName', 'LastName', 'testaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@example.com', '12345', 'failure - email too long')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000005E92570&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000005E92060&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000005E92600&gt;, ...}
test_name = 'Very long email', first_name = 'FirstName', last_name = 'LastName'
email = 'testaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa@example.com'
password = '12345', expected_outcome = 'failure - email too long'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Very long email' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data22]" time="41.019"><failure message="Failed: Test case 'First name exceeding character limit' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000000F928D0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000000F92450&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000000F92950&gt;, ...}
test_name = 'First name exceeding character limit', first_name = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
last_name = 'LastName', email = 'test9999@example.com', password = '12345', expected_outcome = 'failure - first name too long'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000004DF3350&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000005CA4E00&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000000F928D0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000000F92450&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000000F92950&gt;, ...}
test_data = ('First name exceeding character limit', 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA', 'LastName', 'test9999@example.com', '12345', 'failure - first name too long')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000000F928D0&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000000F92450&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000000F92950&gt;, ...}
test_name = 'First name exceeding character limit', first_name = 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'
last_name = 'LastName', email = 'test9999@example.com', password = '12345', expected_outcome = 'failure - first name too long'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'First name exceeding character limit' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase><testcase classname="tests.test_registration" name="test_registration_cases[test_data23]" time="41.623"><failure message="Failed: Test case 'Last name exceeding character limit' failed: Timeout reached.">portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000007BF8E50&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000007BF8F50&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000007BF9050&gt;, ...}
test_name = 'Last name exceeding character limit', first_name = 'FirstName'
last_name = 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB', email = 'test9999@example.com', password = '12345'
expected_outcome = 'failure - last name too long'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
&gt;           await login.fill_login_form(email, password)

tests\test_registration.py:70: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
pages\login_form.py:10: in fill_login_form
    await self.page.fill("input#loginEmail", email)
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\async_api\_generated.py:10082: in fill
    await self._impl_obj.fill(
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_page.py:872: in fill
    return await self._main_frame.fill(**locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_frame.py:527: in fill
    await self._channel.send("fill", locals_to_params(locals()))
..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:61: in send
    return await self._connection.wrap_api_call(
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

self = &lt;playwright._impl._connection.Connection object at 0x0000000005E23A50&gt;, cb = &lt;function Channel.send.&lt;locals&gt;.&lt;lambda&gt; at 0x0000000005DC28E0&gt;, is_internal = False

    async def wrap_api_call(
        self, cb: Callable[[], Any], is_internal: bool = False
    ) -&gt; Any:
        if self._api_zone.get():
            return await cb()
        task = asyncio.current_task(self._loop)
        st: List[inspect.FrameInfo] = getattr(task, "__pw_stack__", inspect.stack())
        parsed_st = _extract_stack_trace_information_from_stack(st, is_internal)
        self._api_zone.set(parsed_st)
        try:
            return await cb()
        except Exception as error:
&gt;           raise rewrite_error(error, f"{parsed_st['apiName']}: {error}") from None
E           playwright._impl._errors.TimeoutError: Page.fill: Timeout 30000ms exceeded.
E           Call log:
E             - waiting for locator("input#loginEmail")

..\..\..\..\AppData\Local\Programs\Python\Python313\Lib\site-packages\playwright\_impl\_connection.py:528: TimeoutError

During handling of the above exception, another exception occurred:

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000007BF8E50&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000007BF8F50&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000007BF9050&gt;, ...}
test_data = ('Last name exceeding character limit', 'FirstName', 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB', 'test9999@example.com', '12345', 'failure - last name too long')

    @pytest.mark.parametrize("test_data", [
        pytest.param(("Valid registration", "FirstName", "LastName", "test9999@example.com", "12345", "success")),
        pytest.param(("Invalid email", "FirstName", "LastName", "invalid_email", "12345", "failure - invalid email")),
        pytest.param(("Empty email", "FirstName", "LastName", "", "12345", "failure - email required")),
        pytest.param(("Email with spaces", "FirstName", "LastName", "test @domain.com", "12345", "failure - invalid email")),
        pytest.param(("Invalid email format", "FirstName", "LastName", "a@a", "12345", "failure - invalid email")),
        pytest.param(("Empty first name", "", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Empty last name", "FirstName", "", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Empty password", "FirstName", "LastName", "test9999@example.com", "", "failure - password required")),
        pytest.param(("Short password", "FirstName", "LastName", "test9999@example.com", "123", "failure - password too short")),
        pytest.param(("Long password", "FirstName", "LastName", "test9999@example.com", "123456789012345678901234567890", "failure - password too long")),
        pytest.param(("Special characters in name", "First@Name", "Last#Name", "test9999@example.com", "12345", "failure - invalid name")),
        pytest.param(("Whitespace-only first name", "   ", "LastName", "test9999@example.com", "12345", "failure - first name required")),
        pytest.param(("Whitespace-only last name", "FirstName", "   ", "test9999@example.com", "12345", "failure - last name required")),
        pytest.param(("Whitespace-only password", "FirstName", "LastName", "test9999@example.com", "   ", "failure - password required")),
        pytest.param(("Duplicate email registration", "FirstName", "LastName", "team2@taqc.com", "12345", "failure - email already in use")),
        pytest.param(("Missing all fields", "", "", "", "", "failure - all fields required")),
        pytest.param(("Email with special characters", "FirstName", "LastName", "test!@domain.com", "12345", "failure - invalid email")),
        pytest.param(("Email without domain", "FirstName", "LastName", "test@", "12345", "failure - invalid email")),
        pytest.param(("Password with only numbers", "FirstName", "LastName", "test9999@example.com", "12345678", "failure - weak password")),
        pytest.param(("Password with only letters", "FirstName", "LastName", "test9999@example.com", "abcdefgh", "failure - weak password")),
        pytest.param(("Password with special characters only", "FirstName", "LastName", "test9999@example.com", "@#$%^&amp;*", "failure - weak password")),
        pytest.param(("Very long email", "FirstName", "LastName", "test" + "a" * 250 + "@example.com", "12345", "failure - email too long")),
        pytest.param(("First name exceeding character limit", "A" * 100, "LastName", "test9999@example.com", "12345", "failure - first name too long")),
        pytest.param(("Last name exceeding character limit", "FirstName", "B" * 100, "test9999@example.com", "12345", "failure - last name too long")),
    ])
    @pytest.mark.asyncio
    async def test_registration_cases(portal_page, test_data):
        test_name, first_name, last_name, email, password, expected_outcome = test_data
&gt;       await run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome)

tests\test_registration.py:133: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 

portal_page = {'cart_sidebar': &lt;pages.components.cart_sidebar.CartSidebar object at 0x0000000007BF8E50&gt;, 'home': &lt;pages.automation_p...ect at 0x0000000007BF8F50&gt;, 'login_popup': &lt;pages.components.login_popup.LoginPopup object at 0x0000000007BF9050&gt;, ...}
test_name = 'Last name exceeding character limit', first_name = 'FirstName'
last_name = 'BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB', email = 'test9999@example.com', password = '12345'
expected_outcome = 'failure - last name too long'

    @pytest.mark.asyncio
    async def run_test_case(portal_page, test_name, first_name, last_name, email, password, expected_outcome="success"):
        home = portal_page["home"]
        register = portal_page["register"]
        login = portal_page["login"]
        navbar = portal_page["navbar"]
        login_popup = portal_page["login_popup"]
        page = home.page
    
        print(f"\nRunning test case: {test_name}")
    
        await home.navigate()
        await home.close_newsletter_popup()
        await navbar.navigate_to_account()
        await login_popup.open_new_customer_popup()
    
        try:
            await page.wait_for_selector("form#register-form", timeout=3000)
    
            await register.fill_registration_form(first_name, last_name, email, password)
    
            fields_to_validate = [
                ("firstName", first_name, "The first name field is invalid."),
                ("lastName", last_name, "The last name field is invalid."),
                ("email", email, "The email field is invalid."),
                ("password", password, "The password field is invalid."),
            ]
    
            is_negative_test = expected_outcome.startswith("failure")
            validation_errors = []
    
            for field_name, value, error_message in fields_to_validate:
                selector = f"form#register-form input[name='{field_name}']"
                if value:
                    is_valid = await page.evaluate(
                        """(field) =&gt; field.checkValidity()""",
                        await page.query_selector(selector)
                    )
                    if not is_valid:
                        validation_errors.append(f"{error_message} Value: '{value}'")
                else:
                    is_required = await page.evaluate(
                        """(field) =&gt; field.required""",
                        await page.query_selector(selector)
                    )
                    if is_required:
                        validation_errors.append(f"The field '{field_name}' is required but empty.")
    
            if validation_errors:
                print("Validation errors detected:")
                for error in validation_errors:
                    print(error)
                if not is_negative_test:
                    pytest.fail(f"Test case '{test_name}' failed: Validation errors detected for success case.")
                else:
                    print(f"Test {test_name}: Form submission blocked as expected for {expected_outcome}")
                    return  # El test pasa si las validaciones bloquean el envío
    
            # Si no hay errores de validación, intentar enviar el formulario
            await register.submit_registration()
            await page.wait_for_timeout(2000)
    
            # Intentar login para verificar si el registro fue exitoso
            print("Attempting login after registration...")
            await login.fill_login_form(email, password)
            await login.submit_login()
    
            try:
                await page.wait_for_url(BASE_URL + "/my-account", timeout=5000)
                login_successful = True
                print(f"Test {test_name}: Registration and login successful")
            except TimeoutError:
                login_successful = False
                print(f"Test {test_name}: Login failed after registration")
    
            if is_negative_test:
                if login_successful:
                    pytest.fail(f"Test case '{test_name}' failed: Unexpected successful login for {expected_outcome}.")
                else:
                    print(f"Test {test_name}: Login failed as expected for {expected_outcome}")
            else:
                if login_successful:
                    user_id = APIHelper.get_user_id(email)
                    if user_id:
                        if APIHelper.delete_user(user_id):
                            print(f"User with ID {user_id} deleted successfully")
                        else:
                            print(f"Error deleting user with ID {user_id}")
                    else:
                        print(f"Could not retrieve user ID for email {email}")
                    print("Result: Success as expected")
                else:
                    pytest.fail(f"Test case '{test_name}' failed: Login failed when success was expected.")
    
        except TimeoutError:
            print(f"Timeout reached in test case '{test_name}'. Closing the test.")
&gt;           pytest.fail(f"Test case '{test_name}' failed: Timeout reached.")
E           Failed: Test case 'Last name exceeding character limit' failed: Timeout reached.

tests\test_registration.py:102: Failed</failure></testcase></testsuite></testsuites>